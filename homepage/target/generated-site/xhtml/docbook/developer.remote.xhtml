<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator"
    content="HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net" />
    <meta http-equiv="Content-Type"
    content="text/html; charset=ISO-8859-1" />
    <title>
      Chapter 20. Remoting
    </title>
    <link rel="stylesheet" href="css/html.css" type="text/css" />
    <meta name="generator"
    content="DocBook XSL-NS Stylesheets V1.75.2" />
    <link rel="home" href="openengsb-manual.html"
    title="OpenEngSB Manual" />
    <link rel="up" href="user.manual.html"
    title="Part III. OpenEngSB Framework" />
    <link rel="prev" href="developer.taskbox.html"
    title="Chapter 19. Taskbox" />
    <link rel="next" href="developer.plugins.html"
    title="Chapter 21. External Domains and Connectors" />
  </head>
  <body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
  alink="#0000FF">
    <div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top">
      <div id="header">
      </div>
    </div>
    <div class="chapter" title="Chapter 20. Remoting">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title">
              <a id="developer.remote"
              name="developer.remote"></a>Chapter 20. Remoting
            </h2>
          </div>
        </div>
      </div>
      <p>
        The OpenEngSB provides interfaces for interacting with
        other applications on the network in a generic way that
        allows using any programming language, transport protocol
        and message marshalling/encoding. This does not mean that
        it magically supports all protocols and encodings, but
        rather that it provides a generic API that provides means
        for integration of new protocols etc. All external
        communication is based on single messages, which means the
        whole mechanism is stateless on its own. To realize
        stateful computations, either the filter(s) or the service
        must provide such functionality.
      </p>
      <div class="section" title="20.1. Filters">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">
                <a id="developer.remote.filters"
                name="developer.remote.filters"></a>20.1. Filters
              </h2>
            </div>
          </div>
        </div>
        <p>
          Following the <a class="ulink"
          href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern"
           target="_top">"Chain of Responsibility"-Pattern</a> the
          OpenEngSB uses Filters to modularize the processing and
          transport of incoming and outgoing messages (see <a
          class="xref"
          href="developer.remote.html#filters.architecture"
          title="Figure 20.1. How filters fit in the architecture">Figure 20.1,
          “How filters fit in the architecture”</a>). A filter is
          responsible for one (or more) specific transformation
          steps. Ideally a Filter should only represent a specific
          transformation step to increase reusability.
        </p>
        <div class="figure">
          <a id="filters.architecture"
          name="filters.architecture"></a>
          <div class="figure-contents">
            <img src="graphics/filtersinarchitecture.png"
            align="middle"
            alt="How filters fit in the architecture" />
          </div>
          <p class="title">
            <b>Figure 20.1. How filters fit in the architecture</b>
          </p>
        </div><br class="figure-break" />
        <p>
          A filter is responsible for both ways of a transformation
          (for example a filter that parses a request is also
          responsible for marshalling the result). Since it is a
          chain of filters, every filter has a successor (next)
          where it passes it's transformed request. After the next
          filter is done and returns a result the current filter
          transforms the message to the desired output format. This
          gives filterchains a pyramid-like architecture (see <a
          class="xref" href="developer.remote.html#filters.pyramid"
          title="Figure 20.2. Pyramid-like architecture of filters">Figure 20.2,
          “Pyramid-like architecture of filters”</a>)
        </p>
        <div class="figure">
          <a id="filters.pyramid" name="filters.pyramid"></a>
          <div class="figure-contents">
            <img src="graphics/filterpyramid.png" align="middle"
            alt="Pyramid-like architecture of filters" />
          </div>
          <p class="title">
            <b>Figure 20.2. Pyramid-like architecture of
            filters</b>
          </p>
        </div><br class="figure-break" />
        <p>
          Example: Typically an incoming remote call can be divided
          into the following steps:
        </p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
              receive: Reads the message in raw form a network
              stream.
            </li>
            <li class="listitem">
              unmarshal request: transform the raw stream into a
              MethodCall object
            </li>
            <li class="listitem">
              handle the request: resolve the corresponding
              osgi-service, invoke the method and wrap the result
              in a MethodResult object
            </li>
            <li class="listitem">
              marshal result: marshal the result for transporting
              it over the network
            </li>
            <li class="listitem">
              send result: send the result back to the caller over
              the network
            </li>
          </ul>
        </div>
        <p>
          A port realizing such a transport would consist of a task
          listening for incoming messages and a chain with two
          Filters: One for marshalling and one handling the request
          itself. An example for such an implementation is the
          "jms-json-basic"-port in the "openengsb-ports-jms"
          project. The incoming port is represented by a single
          that listens on a specific jms-queue for new requests. If
          a Text-message is received it is passed on to the
          filterchain as a string. The filterchain starts with a
          "JsonMethodCallMarshalFilter". As the name indicates,
          this filter expects a string containing a json-encoded
          MethodCall. The string is transformed into a
          MethodCallRequest object and passed on to the next
          filter. The next filter is the RequestHandlerFilter. It
          extracts the MethodCall from the request and passes it on
          to the RequestHandler and wraps the returned MethodResult
          into a MethodResultMessage. The MethodResultMessage is
          then returned to the "JsonMethodCallMarshalFilter". There
          the MethodResultMessage is encoded in JSON and returned
          to the MessageHandler which then sends it to the
          answer-queue. In the JMS-Port the result is sent to a
          queue named after the "callId" submitted in the Request.
          The callId however cannot necessarily be extracted from
          the plain-text message at the beginning of the chain.
          Therefore a map containing values obtained in the filter
          chain (propertyContainer) is passed in to each filter
          during processing.
        </p>
        <p>
          This is only a specific example of creating a port.
          Another port behaving similarly but using xml as encoding
          can easily be configured. It can use the same bean but
          with a different filterchain. In the filterchain the
          first element is replaced by an
          XMLMethodCallMarshalFilter. the RequestHandlerFilter is
          the same as in the jms-json-port.
        </p>
      </div>
      <div class="section" title="20.2. Configure a filterchain">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">
                <a id="developer.remote.filterconfig"
                name="developer.remote.filterconfig"></a>20.2. Configure
                a filterchain
              </h2>
            </div>
          </div>
        </div>
        <p>
          An instance of FilterChainElement may only be part of one
          FilterChain. In order to reuse FilterChainElements in
          other filterchains new instances must be created. This is
          because the instances of the filters may contain
          references to the next element in the chain.
        </p>
        <p>
          That's why Filterchains are supposed to be configured
          using a FilterChainFactory. A filterchain is a bean
          configured with a list of filters. Each element may
          either be the Classname of a FilterAction-class (which
          must have a public default constructor) or an instance of
          a FilterChainElementFactory. The last element in the list
          may also be an instance of a FilterAction (or other
          FilterChain). The following example shows how to
          configure a port via blueprint.
        </p>
<pre xml:space="preserve" class="programlisting">
&lt;bean id="incomingFilterChainFactory" class="org.openengsb.core.common.remote.FilterChainFactory"&gt;
  &lt;property name="inputType" value="java.lang.String" /&gt;
  &lt;property name="outputType" value="java.lang.String" /&gt;
  &lt;!-- the list of filters --&gt;
  &lt;property name="filters"&gt;
    &lt;list&gt;
      &lt;!-- A class implementing the FilterChainElement-interface --&gt;
      &lt;value&gt;org.openengsb.core.common.remote.JsonMethodCallMarshalFilter&lt;/value&gt;
      &lt;!-- instance of a filter-factory --&gt;
      &lt;bean class="org.openengsb.ports.myport.MyFilterFactory"&gt;
        &lt;propety name="foo" value="bar" /&gt;
      &lt;/bean&gt;
      &lt;!-- The last item in the list may be an instance of a FilterAction --&gt;
      &lt;bean class="org.openengsb.core.common.remote.RequestMapperFilter"&gt;
        &lt;property name="requestHandler" ref="requestHandler" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
   
</pre>
        <p>
          When configuring the filter-chain you have to make sure
          that each filter in the list is compatible with its
          predecessor. Compatibility is checked when the
          create-method is invoked. In the above example this would
          be while processing the blueprint-file.
        </p>
      </div>
      <div class="section" title="20.3. Develop custom filters">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">
                <a id="developer.remote.customfilters"
                name="developer.remote.customfilters"></a>20.3. Develop
                custom filters
              </h2>
            </div>
          </div>
        </div>
        <p>
          The filters provided by the openengsb only cover the the
          requirements for the ports that are provided by the
          openengsb itself. For custom ports, custom filter-classes
          may be required.
        </p>
        <p>
          Filterclasses that are to be used at the end of a chain
          must implement the FilterAction-interface. In order to be
          usable anywhere in the filterchain the Classes must
          implement the FilterChainElement-interface. The
          interfaces do not use generic parameters because the
          benefit is really minimal as the information is erased
          during compilation. There are however abstract classes
          (with generic paremeters) that make it easier to
          implement new FilterChainElements
        </p>
      </div>
      <div class="section" title="20.4. Develop an incoming port">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">
                <a id="developer.remote.incoming"
                name="developer.remote.incoming"></a>20.4. Develop
                an incoming port
              </h2>
            </div>
          </div>
        </div>
        <p>
          Incoming ports receive messages and process them using a
          filterchain. There are no restrictions on how the
          implementation of the incoming port actually looks like.
          Typically an incoming port is an object that spawns a
          listening thread and uses a filterchain to process
          incoming messages. This is an example of how the incoming
          port for JMS could look like.
        </p>
<pre xml:space="preserve" class="programlisting">
&lt;!-- example of a bean representing an incoming port --&gt;
&lt;bean id="incomingPortBean" class="org.openengsb.ports.myport.MyIncomingPort" init-method="start" destroy-method="stop"&gt;
  &lt;property name="factory"&gt;
    &lt;bean class="org.openengsb.ports.jms.JMSTemplateFactoryImpl" /&gt;
  &lt;/property&gt;
  &lt;property name="filterChain"&gt;
    &lt;bean factory-ref="incomingFilterChainFactory" factory-method="create" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;
   
</pre>
        <p>
          Every filterchain should use make sure to pass the
          MethodCall to the RequestHandler in the and (using a
          RequestHandlerFilter.
        </p>
      </div>
      <div class="section" title="20.5. Develop an Outgoing port">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">
                <a id="developer.remote.outgoing"
                name="developer.remote.outgoing"></a>20.5. Develop
                an Outgoing port
              </h2>
            </div>
          </div>
        </div>
        <p>
          Outgoing port implementations must follow a few more
          guidelines than incoming ports, because the OpenEngSB
          needs to be aware of Outgoing ports present in the system
          in order to use them in other components (like
          RemoteEvents).
        </p>
        <p>
          An outgoing ports is represented as an OSGi-service that
          implements the OutgoingPort-interface. Also it uses the
          "id"-property (not to be confused with "service.id"
          defined in the OSGi-spec) as a unique identification for
          components that want to interact with remote
          applications. A reference implementation of the
          OutgoingPort-interface is provided in the
          "openengsb-core-common"-project.
        </p>
<pre xml:space="preserve" class="programlisting">
&lt;!-- service representing the outgoing port --&gt;
&lt;service interface="org.openengsb.core.api.remote.OutgoingPort"&gt;
  &lt;service-properties&gt;
    &lt;entry key="id" value="jms-json" /&gt;
  &lt;/service-properties&gt;
  &lt;!-- the outgoing port uses a filter-chain to manage the entire calling-procedure --&gt;
  &lt;bean class="org.openengsb.core.common.OutgoingPortImpl"&gt;
    &lt;property name="filterChain"&gt;
      &lt;bean factory-ref="outgoingFilterChainFactory" factory-method="create" /&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/service&gt;
     
</pre>
        <p>
          The actual network-communication is also implemented in a
          FilterAction. This is an example how a filterchain can be
          used to handle an outgoing methodCall with a result.
        </p>
<pre xml:space="preserve" class="programlisting">
&lt;bean id="outgoingFilterChainFactory" class="org.openengsb.core.common.remote.FilterChainFactory"&gt;
  &lt;property name="inputType" value="org.openengsb.core.api.remote.MethodCallRequest" /&gt;
  &lt;property name="outputType" value="org.openengsb.core.api.remote.MethodResultMessage" /&gt;
  &lt;property name="filters"&gt;
    &lt;list&gt;
      &lt;value&gt;org.openengsb.core.common.remote.JsonOutgoingMethodCallMarshalFilter&lt;/value&gt;
      &lt;bean class="org.openengsb.ports.jms.JMSOutgoingPortFilter"&gt;
        &lt;property name="factory"&gt;
          &lt;bean class="org.openengsb.ports.jms.JMSTemplateFactoryImpl" /&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
     
</pre>
      </div>
    </div>
    <div xmlns:fo="http://www.w3.org/1999/XSL/Format"
    class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left">
            <a accesskey="p"
            href="developer.taskbox.html">Prev</a> 
          </td>
          <td width="20%" align="center">
            <a accesskey="h" href="openengsb-manual.html">Home</a>
          </td>
          <td width="40%" align="right">
             <a accesskey="n"
            href="developer.plugins.html">Next</a>
          </td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">
            Chapter 19. Taskbox 
          </td>
          <td width="20%" align="center">
            <span style="color:white;font-size:85%;"><a
            href="http://openengsb.org/"
            title="OpenEngSB Community">OpenEngSB
            Community</a></span>
          </td>
          <td width="40%" align="right" valign="top">
             Chapter 21. External Domains and Connectors
          </td>
        </tr>
      </table>
    </div>
  </body>
</html>
