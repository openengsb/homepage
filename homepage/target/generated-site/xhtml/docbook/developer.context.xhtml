<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator"
    content="HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net" />
    <meta http-equiv="Content-Type"
    content="text/html; charset=ISO-8859-1" />
    <title>
      Chapter 15. Context Management
    </title>
    <link rel="stylesheet" href="css/html.css" type="text/css" />
    <meta name="generator"
    content="DocBook XSL-NS Stylesheets V1.75.2" />
    <link rel="home" href="openengsb-manual.html"
    title="OpenEngSB Manual" />
    <link rel="up" href="user.manual.html"
    title="Part III. OpenEngSB Framework" />
    <link rel="prev" href="architecture.html"
    title="Chapter 14. Architecture of the OpenEngSB" />
    <link rel="next" href="developer.persistence.html"
    title="Chapter 16. Persistence in the OpenEngSB" />
  </head>
  <body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
  alink="#0000FF">
    <div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top">
      <div id="header">
      </div>
    </div>
    <div class="chapter" title="Chapter 15. Context Management">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title">
              <a id="developer.context"
              name="developer.context"></a>Chapter 15. Context
              Management
            </h2>
          </div>
        </div>
      </div>
      <p>
        The context is one of the most important core concepts of
        the openengsb. It allows to reuse predefined workflows in
        several contexts. A context may often represent a project
        or subproject. So it is possible to execute the same
        workflow with the project-specific tool-instances and other
        metadata (like contact-information).
      </p>
      <p>
        To determine in which context an action should be executed
        a thread-local variable is used. The <a class="link"
        href="https://github.com/openengsb/openengsb/blob/master/core/api/src/main/java/org/openengsb/core/api/context/ContextHolder.java"
         target="_top">ContextHolder</a> keeps track of this
        variable (the current threads' context). Invoking the set-
        and get-method will always manipulate the context of the
        current Thread. When a new Thread is spawned it inherits
        the context from the parent thread.
      </p>
      <p>
        <span class="emphasis"><em>Attention:</em></span> When
        using Theadpools, the ContextHolder may malfunction (i.e.
        return the context of some previous task that was run in
        the same thread). Use
      </p>
<pre xml:space="preserve" class="programlisting">
ThreadLocalUtil.contextAwareExecutor(ExecutorService)
</pre>
      <p>
        to convert any executor to a context-aware one.
        ExecutorServices returned by this method ensure that the
        submitted tasks are executed in the same context as the
        thread they were submitted from.
      </p>
      <p>
        This way connector-implementations and other client
        projects always can handle actions according to the current
        context, and execute actions in specific a specific
        context. So when a person with a certain role in the
        project (e.g. project manager) needs to be notified of some
        event, the value of his contact-address is specific to the
        context of the project(s) he is managing.
      </p>
      <div class="section" title="15.1. Wiring services">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">
                <a id="developer.context.wiring"
                name="developer.context.wiring"></a>15.1. Wiring
                services
              </h2>
            </div>
          </div>
        </div>
        <p>
          The context is also used to handle the wiring of services
          in workflows. Suppose there are two projects that use
          their own SCM-repositories and for both repositories
          connector-instances were created to poll them. When
          executing a workflow contains an action that polls the
          SCM, the correct service ca be picked by looking up the
          current thread's context.
        </p>
        <p>
          In general workflows have references to several domains
          and other services which they interact with during
          execution. Each project might have their own tools behind
          these domains, so these references must be resolved at
          runtime depending on the current context.
        </p>
        <p>
          For this to work the workflow-engine declares global
          variables that are used in rules and processes. A
          variable is resolved by looking up the service with the
          same name in the current context. If no service with that
          name is available in the context it is looked up in the
          "root"-context.
        </p>
        <p>
          In detail the wiring is handled via the
          service-properties. Services contain properties where the
          key is of the format "location.&lt;contextid&gt;". The
          value is a list of "locations" represented by an array of
          strigns. So a service may have several locations in
          several contexts.
        </p>
        <p>
          When a global variable is accessed during the execution
          of an action (from a process or rule), the osgi-context
          is queried for the correspinding service. The service
          wired to this variable must have location with the same
          name as the variable. The service is searched in the
          current context and the root-context. If no service is
          found, the action is stalled for 30 seconds. If there is
          still no service found an Exception is thrown. Internally
          this is handled using proxies. When the workflow service
          is started, all globals are populated with proxies, that
          automatically resolve the service with the corresponding
          location when a method is invoked.
        </p>
        <p>
          Example: The auditing-service is registered with the
          interface AuditingDomain. The service has property
          "location.root" with value {"auditing"} (array with one
          element). The workflow engine contains a global named
          "auditing" and a rule that invokes a method on every
          Event that is processed. When the rule fires and the
          consequence is executed, the proxy representing
          "auditing"-global queries for a service with the
          location.currentContext or the location.root containing a
          location-entry "auditing". Since root-services get a
          service-ranking of "-1" by default, the service current
          context's would supersede the service located in the
          root-context.
        </p>
      </div>
    </div>
    <div xmlns:fo="http://www.w3.org/1999/XSL/Format"
    class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left">
            <a accesskey="p" href="architecture.html">Prev</a> 
          </td>
          <td width="20%" align="center">
            <a accesskey="h" href="openengsb-manual.html">Home</a>
          </td>
          <td width="40%" align="right">
             <a accesskey="n"
            href="developer.persistence.html">Next</a>
          </td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">
            Chapter 14. Architecture of the OpenEngSB 
          </td>
          <td width="20%" align="center">
            <span style="color:white;font-size:85%;"><a
            href="http://openengsb.org/"
            title="OpenEngSB Community">OpenEngSB
            Community</a></span>
          </td>
          <td width="40%" align="right" valign="top">
             Chapter 16. Persistence in the OpenEngSB
          </td>
        </tr>
      </table>
    </div>
  </body>
</html>
